/****************************************************************************************************************************************************\
 *** 
 *** Simulink model       : APSA
 *** TargetLink subsystem : APSA/APSA
 *** Codefile             : APSA.c
 ***
 *** Generated by TargetLink, the dSPACE production quality code generator
 *** Generation date: 2016-05-17 16:10:11
 ***
 *** CODE GENERATOR OPTIONS:
 *** Code generation mode                     : Standard
 *** Compiler                                 : <unknown>
 *** Target                                   : Generic
 *** ANSI-C compatible code                   : yes
 *** Code Optimization                        : enabled
 *** Constant style                           : decimal
 *** Clean code option                        : enabled
 *** Logging mode                             : Do not log anything
 *** Code Coverage                            : disabled
 *** Generate empty conditional branches      : disabled
 *** Loop unroll threshold                    : 5
 *** Variable vector widths                   : enabled
 *** Shift mode                               : automatic
 *** Handle unscaled SF expr. with TL type    : enabled
 *** Assignment of conditions                 : AllBooleanOutputs 
 *** Scope reduction only to function level   : disabled
 *** Exploit ranges if not erasable           : disabled
 *** Exploit Compute Through Overflow         : optimized
 *** Linker sections                          : enabled
 *** Enable Assembler                         : disabled
 *** Variable name length                     : 31 chars
 *** Use global bitfields                     : disabled
 *** Stateflow: use of bitfields              : enabled
 *** State activity encoding limit            : 5
 *** Omit zero inits in restart function      : disabled
 *** Share functions between TL subsystems    : disabled
 *** Generate 64bit functions                 : enabled
 *** Inlining Threshold                       : 6
 *** Line break limit                         : 150
 *** Target optimized boolean data type       : enabled
 *** Keep saturation elements                 : disabled
 *** Extended variable sharing                : disabled
 *** Extended lifetime optimization           : enabled
 *** Style definition file                    : C:\Program Files\dSPACE TargetLink 4.0\Matlab\Tl\Config\codegen\cconfig.xml
 *** Root style sheet                         : C:\Program Files\dSPACE TargetLink 4.0\Matlab\Tl\XML\CodeGen\Stylesheets\TL_CSourceCodeSS.xsl
 ***
 *** SUBSYS                   CORRESPONDING SIMULINK SUBSYSTEM
 *** Sa1                      APSA
 *** Sa2                      APSA/FILTER8samples1
 *** Sa3                      APSA/Hall_Counter_Backward
 *** 
 *** SUBSYS                   CORRESPONDING MODEL BLOCK (REFERENCED MODEL)
 *** 
 *** SF-NODE         CORRESPONDING STATEFLOW NODE                                                       DESCRIPTION
 *** Ca0             APSA                                                                               
 *** Ca1             APSA/APSA_chart                                                                    
 *** Ca2             APSA/APSA_chart.Calculate_Lenght_Segment                                           
 *** Ca3             APSA/APSA_chart.Check_Min_Threshold                                                
 *** Ca4             APSA/APSA_chart.Init                                                               
 *** Ca5             APSA/APSA_chart.SetTimer_Delay                                                     
 *** Ca6             APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD                                           
 *** Ca7             APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_INRUSH_TIME_FORWARD                  
 *** Ca8             APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.Antipinch_Active                          
 *** Ca9             APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_ADAPTATION_TIME_FORWARD              
 *** Ca10            APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD                   
 *** Ca11            APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD.CounterManagerDow
 ***                 nFwd                                                                               
 *** Ca12            APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD.CounterManagerUpF
 ***                 wd                                                                                 
 *** Ca13            APSA/APSA_chart.IDLE                                                               
 *** Ca14            APSA/APSA_chart.WRITE_MAP_FORWARD                                                  
 *** Ca15            APSA/APSA_chart.WRITE_MAP_BACKWARD                                                 
 *** Ca16            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD                                          
 *** Ca17            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_INRUSH_TIME_BACKWARD                
 *** Ca18            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.Antipinch_Active                         
 *** Ca19            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_ADAPTATION_TIME_BACKWARD            
 *** Ca20            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD                 
 *** Ca21            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD.CounterManagerD
 ***                 ownBwd                                                                             
 *** Ca22            APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD.CounterManagerU
 ***                 pBwd                                                                               
 *** Ca23            APSA/FILTER8samples1/Average_mobile_Filter_8samp                                   
 *** Ca24            APSA/FILTER8samples1/Average_mobile_Filter_8samp.AVERAGE                           
 *** 
 *** TargetLink version      : 4.0 from 30-Oct-2014
 *** Code generator version  : Build Id 4.0.0.23 from 2014-10-21 15:54:50
 *** Copyright (c) 2014 dSPACE GmbH
\****************************************************************************************************************************************************/

#ifndef APSA_C
#define APSA_C

/*------------------------------------------------------------------------------------------------------------------*\
  DEFINES (OPT)
\*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*\
  INCLUDES
\*------------------------------------------------------------------------------------------------------------------*/
#include "APSA_Config.h"
#include "APSA.h"
/*------------------------------------------------------------------------------------------------------------------*\
  DEFINES
\*------------------------------------------------------------------------------------------------------------------*/

/********************************************************************************************************************\
   TL_CG_MACROCL_GLOBALSrToLocal_a: TL CG ScopeReducedClass : derived from TL_CG_MACROCL_GLOBAL
\********************************************************************************************************************/
#define Ca13_IDLE_id ((UInt8) 2)
#define Ca14_WRITE_MAP_FORWARD_id ((UInt8) 3)
#define Ca15_WRITE_MAP_BACKWARD_id ((UInt8) 4)
#define Ca16_ANTIPINCH__IVE_BACKWARD_id ((UInt8) 5)
#define Ca6_ANTIPINCH_ACTIVE_FORWARD_id ((UInt8) 1)

/*------------------------------------------------------------------------------------------------------------------*\
  TYPEDEFS
\*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*\
  ENUMS
\*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*\
  VARIABLES
\*------------------------------------------------------------------------------------------------------------------*/
/********************************************************************************************************************\
   SFStaticGlobalInit: Default storage class for global static variables with initial value | Width: 16
\********************************************************************************************************************/
static Int16 Ca23_average_filter = 0;

/********************************************************************************************************************\
   SFStaticGlobalInit: Default storage class for global static variables with initial value | Width: 8
\********************************************************************************************************************/
static UInt8 Ca1_BitMaskIndex = 0;
static UInt8 Ca1_BitPosition = 0;
static UInt8 Ca1_Cnt_Fail_Sens_Current = 0;
static UInt8 Ca1_Index_vector = 0;
static UInt8 Ca1_UpdateTrh = 0;
static UInt8 DD_Ca1_Fail_Sens_Current = 0 /* LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 255 */;

/********************************************************************************************************************\
   SLGlobal: Default storage class for global variables | Width: N.A.
\********************************************************************************************************************/
struct BS_IP_Sa1_APSA_INPUT_DELTA APSA_INPUT_DELTA;

struct BS_IP_Sa1_APSA_INPUT_Low_Level APSA_INPUT_Low_Level;

struct BS_IP_Sa1_APSA_INPUT_Mota APSA_INPUT_Mota;

struct BS_OP_Sa1_APSA_OUTPUT APSA_OUTPUT = {
   0 /* Threshold_AntiPinch_Update: LSB: 2^0 OFF:  0 MIN/MAX:  -32768 .. 32767 */, 
   0 /* Threshold_Attention_Update: LSB: 2^0 OFF:  0 MIN/MAX:  -32768 .. 32767 */, 
   0 /* cnt_antipinch:  */, 
   0 /* Antipinch_Active: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 255 */, 
   0 /* Fail_Sens_Current: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 255 */, 
   0 /* Index_vector: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 255 */
};

/********************************************************************************************************************\
   SLGlobalInit: Default storage class for global variables with initial value | Width: 16
\********************************************************************************************************************/
Int16 Current_Read_Average = 0;
Int16 Delta_Current_actual = 0;

/*------------------------------------------------------------------------------------------------------------------*\
  PARAMETERIZED MACROS
\*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*\
  FUNCTION PROTOTYPES
\*------------------------------------------------------------------------------------------------------------------*/
/********************************************************************************************************************\
   StaticSFDuring: Default function class for static stateflow during functions
\********************************************************************************************************************/
static void Ca11_CounterManagerDownFwd(UInt8 Ca11_ResetCounter);
static void Ca12_CounterManagerUpFwd(UInt8 Ca12_ResetCounter);
static void Ca21_CounterManagerDownBwd(UInt8 Ca21_ResetCounter);
static void Ca22_CounterManagerUpBwd(UInt8 Ca22_ResetCounter);
static void Ca3_Check_Min_Threshold(void);

/*------------------------------------------------------------------------------------------------------------------*\
  INLINE FUNCTIONS
\*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*\
  FUNCTION DEFINITIONS
\*------------------------------------------------------------------------------------------------------------------*/

/****************************************************************************************************************************************************\
 ***  FUNCTION:
 ***      APSA
 *** 
 ***  DESCRIPTION:
 ***      
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\****************************************************************************************************************************************************/
void APSA(void)
{
   /* SFStaticLocalInit: Default storage class for static local variables with initvalue | Width: 16 */
   static Int16 Ca1_Average_Current = 0;
   static Int16 Ca1_Average_Difference = 0;
   static Int16 Ca1_Average_EERAM_Current_Map = 0;
   static UInt16 Ca1_Counter_Time = 0;
   static Int16 Ca1_Current_Peak = 0;
   static Int16 Ca1_Current_Read = 0;
   static Int16 Ca1_Delta_Current_previuos = 0;
   static Int16 Ca1_Vbatt_Old = 0;
   static UInt16 Ca1_cnt_antipinch = 0;
   static Int16 circular_buffer[8] = 
   {
      /*[0..7]*/ 0, 0, 0, 0, 0, 0, 0, 0
      /* 0., 0., 0., 0., 0., 0., 0., 0. */
   };

   /* SFStaticLocalInit: Default storage class for static local variables with initvalue | Width: 8 */
   static UInt8 Ca1_APSA_Delay = 0;
   static UInt8 Ca1_Cmd_Motor_Lift_Old = 0;
   static UInt8 Ca1_Counter_Sample_Current = 0;
   static UInt8 Ca1_Index_peak_time = 0;
   static UInt8 Ca1_Lenght_Segment = 0;
   static UInt8 Ca1_Segments_Cnt = 0 /* LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 100 */;

   /* SFStaticLocalInit: Default storage class for static local variables with initvalue | Width: N.A. */
   static struct tag_SIBFS_APSA_chart_a_tp SIBFS_APSA_chart_a = {
      0 /* Ca1_APSA_chart_ns: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 7 */, 
      0 /* Ca17_WAIT_INRUSH_TIME_BACKWARD: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */, 
      0 /* Ca18_Antipinch_Active: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */, 
      0 /* Ca19_WAIT_ADAP__N_TIME_BACKWARD: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */, 
      0 /* Ca7_WAIT_INRUSH_TIME_FORWARD: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */, 
      0 /* Ca8_Antipinch_Active: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */, 
      0 /* Ca9_WAIT_ADAPT__ON_TIME_FORWARD: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */
   } /* Description: Structure containing bitfields for Stateflow chart  */;
   
   static struct tag_SIBFS_Average_mobile_Filter_8samp_a_tp SIBFS_Average____Filter_8samp_a = {
      0 /* Ca24_AVERAGE: LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */
   } /* Description: Structure containing bitfields for Stateflow chart  */;

   /* SLLocal: Default storage class for local variables | Width: 16 */
   Int16 Sa3_Sum;

   /* SLLocal: Default storage class for local variables | Width: 32 */
   Int32 Aux_S32;

   /* SLStaticLocalInit: Default storage class for static local variables with initvalue | Width: 8 */
   static UInt8 X_Sa1_Unit_Delay = 0;

   /* Sum: APSA/Hall_Counter_Backward/Sum */
   Sa3_Sum = (Int16) (((Int16) APSA_INPUT_Mota.Lenght_Motor_Stroke) - APSA_INPUT_Low_Level.Hall_Counter);

   /* Begin execution of chart APSA/FILTER8samples1/Average_mobile_Filter_8samp */
   if (SIBFS_Average____Filter_8samp_a.Ca24_AVERAGE) {
      /* Begin execution of state APSA/FILTER8samples1/Average_mobile_Filter_8samp.AVERAGE */
      if (X_Sa1_Unit_Delay == 1) {
         /* State transition from APSA/FILTER8samples1/Average_mobile_Filter_8samp.AVERAGE to APSA/FILTER8samples1/Average_mobile_Filter_8samp.AVERAGE
          */
         for (Aux_S32 = 0; Aux_S32 < 8; Aux_S32++)
         {
            circular_buffer[Aux_S32] = 0;
         }
         SIBFS_Average____Filter_8samp_a.Ca24_AVERAGE = 1;
      }
      else {
         /* SFLocalInit: Default storage class for local variables with init values | Width: 16 */
         Int16 Ca23_sum_samples;
         Int16 Ca23_sum_weights;

         /* SFLocalInit: Default storage class for local variables with init values | Width: 8 */
         UInt8 Ca23_index_vector_filter;

         Ca23_sum_weights = 1;
         Ca23_sum_samples = 0;
         for (Ca23_index_vector_filter = 0; Ca23_index_vector_filter < (SIZE_FILTER - 1); Ca23_index_vector_filter = Ca23_index_vector_filter + 1)
         {
            circular_buffer[Ca23_index_vector_filter] = circular_buffer[Ca23_index_vector_filter + 1];
            Ca23_sum_samples = (Int16) (Ca23_sum_samples + circular_buffer[Ca23_index_vector_filter]);
            if (circular_buffer[Ca23_index_vector_filter] != 0) {
               Ca23_sum_weights = Ca23_sum_weights + 1;
            }
         }
         circular_buffer[Ca23_index_vector_filter] = (Int16) APSA_INPUT_Low_Level.Current;
         Ca23_sum_samples = (Int16) (Ca23_sum_samples + circular_buffer[Ca23_index_vector_filter]);
         Ca23_average_filter = Ca23_sum_samples / Ca23_sum_weights;
      }

      /* End execution of state APSA/FILTER8samples1/Average_mobile_Filter_8samp.AVERAGE */
   }
   else {
      /* State transition to APSA/FILTER8samples1/Average_mobile_Filter_8samp.AVERAGE */
      for (Aux_S32 = 0; Aux_S32 < 8; Aux_S32++)
      {
         circular_buffer[Aux_S32] = 0;
      }
      SIBFS_Average____Filter_8samp_a.Ca24_AVERAGE = 1;
   }

   /* End execution of chart APSA/FILTER8samples1/Average_mobile_Filter_8samp */

   /* Begin execution of chart APSA/APSA_chart */
   switch (SIBFS_APSA_chart_a.Ca1_APSA_chart_ns) {
      case Ca6_ANTIPINCH_ACTIVE_FORWARD_id: {
         /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD */
         if (APSA_INPUT_Mota.Check_Antipinch == APSA_NOT_ACTIVE) {
            /* State transition from APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD to APSA/APSA_chart.IDLE */
            if (SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD) {
               SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD = 0;
            }
            else {
               if (SIBFS_APSA_chart_a.Ca8_Antipinch_Active) {
                  SIBFS_APSA_chart_a.Ca8_Antipinch_Active = 0;
               }
               else {
                  if (SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD) {
                     SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD = 0;
                  }
               }
            }
            SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca13_IDLE_id;

            /* # combined # BusOutport: APSA/APSA_OUTPUT */
            APSA_OUTPUT.Antipinch_Active = APSA_NOT_ACTIVE;
         }
         else {
            if ((APSA_INPUT_Mota.Check_Antipinch == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_BACKWARD)) {
               /* State transition from APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD to APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD */
               if (SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD) {
                  SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD = 0;
               }
               else {
                  if (SIBFS_APSA_chart_a.Ca8_Antipinch_Active) {
                     SIBFS_APSA_chart_a.Ca8_Antipinch_Active = 0;
                  }
                  else {
                     if (SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD) {
                        SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD = 0;
                     }
                  }
               }
               SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca16_ANTIPINCH__IVE_BACKWARD_id;

               /* ex: EERAM_Current_Map_Backward_Write = EERAM_Current_Map_Backward_Write - (Average_Difference); */
               Ca1_Counter_Time = 0;

               /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_INRUSH_TIME_BACKWARD */
               Ca1_Current_Peak = Ca23_average_filter;
               SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD = 1;
            }
            else {
               if (SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD) {
                  /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_INRUSH_TIME_FORWARD */
                  if (Ca1_Counter_Time >= INRUSH_TIME) {
                     Ca1_Counter_Time = 0;

                     /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_ADAPTATION_TIME_FORWARD */
                     SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD = 0;
                     SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD = 1;
                     Ca1_Average_Current = 0;
                     Ca1_Average_EERAM_Current_Map = 0;
                     Ca1_Average_Difference = 0;
                     Ca1_Segments_Cnt = 0;
                     Ca1_Index_vector = APSA_INPUT_Low_Level.Hall_Counter / Ca1_Lenght_Segment;
                  }
                  else {
                     if (Ca1_Counter_Time < INRUSH_TIME) {
                        Ca1_Counter_Time = Ca1_Counter_Time + 1;
                        if (Ca1_Counter_Time == (INRUSH_TIME - 1)) {
                           /* # combined # Unit delay: APSA/Unit Delay */
                           X_Sa1_Unit_Delay = 1;
                        }
                        else {
                           /* # combined # Unit delay: APSA/Unit Delay */
                           X_Sa1_Unit_Delay = 0;
                        }
                     }
                     if (Ca1_Current_Peak <= Ca23_average_filter) {
                        Ca1_Current_Peak = Ca23_average_filter;
                     }
                  }

                  /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_INRUSH_TIME_FORWARD */
               }
               else {
                  if (!(SIBFS_APSA_chart_a.Ca8_Antipinch_Active)) {
                     if (SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD) {
                        /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_ADAPTATION_TIME_FORWARD */
                        if (Ca1_Counter_Time >= ADAPTATION_TIME) {
                           /* State transition from APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_ADAPTATION_TIME_FORWARD to APSA/APSA_chart.ANTIPINCH
                              _ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD */
                           Ca1_Average_Current = Ca1_Average_Current / Ca1_Counter_Time;
                           Ca1_Average_EERAM_Current_Map = Ca1_Average_EERAM_Current_Map / Ca1_Segments_Cnt;
                           Ca1_Average_Difference = Ca1_Average_Current - Ca1_Average_EERAM_Current_Map;

                           /* EERAM_Current_Map_Forward_Write = EERAM_Current_Map_Forward_Write + (Average_Difference); */
                           Ca1_Delta_Current_previuos = 0;

                           /* # combined # BusOutport: APSA/APSA_OUTPUT */
                           APSA_OUTPUT.Threshold_Attention_Update = (Int16) EERAM_Threshold_Att_Forward;
                           APSA_OUTPUT.Threshold_AntiPinch_Update = (Int16) EERAM_Threshold_Antipinch_Forward;
                           SIBFS_APSA_chart_a.Ca9_WAIT_ADAPT__ON_TIME_FORWARD = 0;
                           Ca1_cnt_antipinch = 0;
                           Ca1_Index_vector = APSA_INPUT_Low_Level.Hall_Counter / Ca1_Lenght_Segment;
                           Ca1_Current_Read = Ca23_average_filter;
                           Ca1_Counter_Sample_Current = 1;
                           Ca1_APSA_Delay = 0;
                           Ca1_Cmd_Motor_Lift_Old = APSA_INPUT_Mota.Cmd_Motor_Lift;
                        }
                        else {
                           if (Ca1_Counter_Time < ADAPTATION_TIME) {
                              Ca1_Counter_Time = Ca1_Counter_Time + 1;
                              Ca1_Average_Current = Ca1_Average_Current + Ca23_average_filter;
                              if ((APSA_INPUT_Low_Level.Hall_Counter >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) &&
                               (Ca1_Index_vector <= (MAX_NUM_ELEMENT - 1))) {
                                 Ca1_Average_EERAM_Current_Map = Ca1_Average_EERAM_Current_Map + EERAM_Current_Map_Forward[Ca1_Index_vector];
                                 Ca1_Index_vector = Ca1_Index_vector + 1;
                                 Ca1_Segments_Cnt = Ca1_Segments_Cnt + 1;
                              }
                           }
                        }

                        /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_ADAPTATION_TIME_FORWARD */
                     }
                     else {
                        /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD */

                        /* # combined # BusOutport: APSA/APSA_OUTPUT */
                        if (APSA_OUTPUT.Antipinch_Active == APSA_ACTIVE) {
                           /* # combined # TargetLink outport: APSA/Current_Read_Average */
                           Current_Read_Average = 0;

                           /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.Antipinch_Active */
                           SIBFS_APSA_chart_a.Ca8_Antipinch_Active = 1;
                        }
                        else {
                           if (Ca1_APSA_Delay > 1) {
                              Ca1_APSA_Delay = Ca1_APSA_Delay - 1;
                           }
                           if (Ca1_cnt_antipinch <= T_ANTIPINCH) {
                              if ((APSA_INPUT_Low_Level.Hall_Counter >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) &&
                               (Ca1_Index_vector < (MAX_NUM_ELEMENT - 1))) {
                                 /* this check is used to avoid currentread saturation 
                                    during drop delay */
                                 if (Ca1_APSA_Delay <= 1) {
                                    /* with voltage drop  || stop lift motor inhibit antipinch for DROP_DELAY */
                                    if (((Ca1_Vbatt_Old - APSA_INPUT_Low_Level.Vbatt) >= VBATT_DROP) || ((APSA_INPUT_Low_Level.Vbatt - Ca1_Vbatt_Old)
                                     >= VBATT_DROP) || ((APSA_INPUT_Mota.Cmd_Motor_Lift == APSA_CMD_STOP) && ((Ca1_Cmd_Motor_Lift_Old ==
                                     APSA_CMD_FORWARD) || (Ca1_Cmd_Motor_Lift_Old == APSA_CMD_BACKWARD)))) {
                                       Ca1_APSA_Delay = DROP_DELAY;
                                    }
                                    else {
                                       /* # combined # TargetLink outport: APSA/Current_Read_Average */
                                       Current_Read_Average = Ca1_Current_Read / Ca1_Counter_Sample_Current;

                                       /* # combined # TargetLink outport: APSA/Delta_Current_actual
                                          # combined # TargetLink outport: APSA/Current_Read_Average */
                                       Delta_Current_actual = Current_Read_Average - (EERAM_Current_Map_Forward[Ca1_Index_vector] +
                                        Ca1_Average_Difference) - Ca1_Delta_Current_previuos;
                                       if (Ca1_APSA_Delay == 1) {
                                          /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                          Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + Delta_Current_actual;
                                          Ca1_APSA_Delay = 0;
                                       }
                                       else {
                                          /* # combined # TargetLink outport: APSA/Delta_Current_actual
                                             # combined # BusOutport: APSA/APSA_OUTPUT */
                                          if ((Delta_Current_actual > APSA_OUTPUT.Threshold_AntiPinch_Update) && (Ca1_cnt_antipinch < T_ANTIPINCH)) {
                                             Ca1_cnt_antipinch = Ca1_cnt_antipinch + 1;
                                             if (L_SHIFT_ADAPTATION != 0) {
                                                /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + ((Delta_Current_actual <<
                                                 L_SHIFT_ADAPTATION) / DIV_ADAPTATION);
                                             }
                                             if (Ca1_cnt_antipinch >= T_ANTIPINCH) {
                                                /* # combined # BusOutport: APSA/APSA_OUTPUT */
                                                APSA_OUTPUT.Antipinch_Active = APSA_ACTIVE;
                                             }
                                          }
                                          else {
                                             Ca1_cnt_antipinch = 0;
                                             Ca1_UpdateTrh = APSA_FALSE;

                                             /* CHECK_ATTENTION_THRESHOLD
                                                UPPER_THRESHOLD
                                                # combined # TargetLink outport: APSA/Delta_Current_actual
                                                # combined # BusOutport: APSA/APSA_OUTPUT */
                                             if (Delta_Current_actual >= APSA_OUTPUT.Threshold_Attention_Update) {
                                                Ca12_CounterManagerUpFwd(APSA_FALSE);

                                                /* # combined # BusOutport: APSA/APSA_OUTPUT */
                                                Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + APSA_OUTPUT.Threshold_Attention_Update;
                                                if ((Ca1_UpdateTrh == APSA_TRUE) && (APSA_INPUT_Low_Level.Enable_Adaptation == APSA_TRUE)) {
                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   EERAM_Current_Map_Forward[Ca1_Index_vector] = EERAM_Current_Map_Forward[Ca1_Index_vector] +
                                                   (Delta_Current_actual / APSA_INPUT_DELTA.DELTA_1);
                                                }
                                             }
                                             else {
                                                /* Reset counter Up */
                                                Ca12_CounterManagerUpFwd(APSA_TRUE);

                                                /* LOWER_THRESHOLD
                                                   # combined # TargetLink outport: APSA/Delta_Current_actual
                                                   # combined # BusOutport: APSA/APSA_OUTPUT
                                                   # combined # TargetLink outport: APSA/Delta_Current_actual
                                                   # combined # BusOutport: APSA/APSA_OUTPUT
                                                   # combined # TargetLink outport: APSA/Current_Read_Average */
                                                if ((Delta_Current_actual <= (-APSA_OUTPUT.Threshold_Attention_Update)) && (Delta_Current_actual >
                                                 (-APSA_OUTPUT.Threshold_AntiPinch_Update)) && (Current_Read_Average > MIN_CURRENT_THRESHOLD)) {
                                                   Ca11_CounterManagerDownFwd(APSA_FALSE);

                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + Delta_Current_actual;
                                                   if ((Ca1_UpdateTrh == APSA_TRUE) && (APSA_INPUT_Low_Level.Enable_Adaptation == APSA_TRUE)) {
                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   EERAM_Current_Map_Forward[Ca1_Index_vector] = EERAM_Current_Map_Forward[Ca1_Index_vector] -
                                                   ((-Delta_Current_actual) / APSA_INPUT_DELTA.DELTA_2);
                                                   }
                                                }
                                                else {
                                                   /* Reset counter Down */
                                                   Ca11_CounterManagerDownFwd(APSA_TRUE);

                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + Delta_Current_actual;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                                 Ca3_Check_Min_Threshold();
                                 Ca1_Index_vector = Ca1_Index_vector + 1;
                                 Ca1_Current_Read = Ca23_average_filter;
                                 Ca1_Counter_Sample_Current = 1;
                                 Ca1_Vbatt_Old = APSA_INPUT_Low_Level.Vbatt;
                                 Ca1_Cmd_Motor_Lift_Old = APSA_INPUT_Mota.Cmd_Motor_Lift;
                              }
                              else {
                                 Ca1_Current_Read = Ca1_Current_Read + Ca23_average_filter;
                                 Ca1_Counter_Sample_Current = Ca1_Counter_Sample_Current + 1;
                              }
                           }
                        }

                        /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD */
                     }
                  }
               }
            }
         }

         /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD */
         break;
      }
      case Ca13_IDLE_id: {
         /* Begin execution of state APSA/APSA_chart.IDLE */
         if ((APSA_INPUT_Mota.Write_Map == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_BACKWARD) && (APSA_INPUT_Low_Level.Enable_APSA ==
          APSA_ACTIVE)) {
            /* State transition from APSA/APSA_chart.IDLE to APSA/APSA_chart.WRITE_MAP_BACKWARD */
            if ((APSA_INPUT_Mota.Lenght_Motor_Stroke % MAX_NUM_ELEMENT) == 0) {
               Ca1_Lenght_Segment = APSA_INPUT_Mota.Lenght_Motor_Stroke / MAX_NUM_ELEMENT;
            }
            else {
               Ca1_Lenght_Segment = (APSA_INPUT_Mota.Lenght_Motor_Stroke / MAX_NUM_ELEMENT) + 1;
            }
            for (Aux_S32 = 0; Aux_S32 < 100; Aux_S32++)
            {
               EERAM_Current_Map_Backward[Aux_S32] = 0;
            }
            SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca15_WRITE_MAP_BACKWARD_id;
            Ca1_Index_vector = Sa3_Sum / Ca1_Lenght_Segment;

            /* Current_Read = Current; */
            Ca1_Current_Read = 0;
            Ca1_Counter_Sample_Current = 1;
            Ca1_Counter_Time = 0;
            Ca1_Index_peak_time = 0;
         }
         else {
            if ((APSA_INPUT_Mota.Check_Antipinch == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_FORWARD) &&
             (APSA_INPUT_Low_Level.Enable_APSA == APSA_ACTIVE)) {
               /* State transition from APSA/APSA_chart.IDLE to APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD */
               SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca6_ANTIPINCH_ACTIVE_FORWARD_id;

               /* ex: EERAM_Current_Map_Forward_Write = EERAM_Current_Map_Forward_Write - (Average_Difference); */
               Ca1_Counter_Time = 0;

               /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_INRUSH_TIME_FORWARD */
               Ca1_Current_Peak = Ca23_average_filter;
               SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD = 1;
            }
            else {
               if ((APSA_INPUT_Mota.Write_Map == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_FORWARD) && (APSA_INPUT_Low_Level.Enable_APSA
                == APSA_ACTIVE)) {
                  /* State transition from APSA/APSA_chart.IDLE to APSA/APSA_chart.WRITE_MAP_FORWARD */
                  for (Aux_S32 = 0; Aux_S32 < 100; Aux_S32++)
                  {
                     EERAM_Current_Map_Forward[Aux_S32] = 0;
                  }
                  SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca14_WRITE_MAP_FORWARD_id;
                  Ca1_Index_vector = APSA_INPUT_Low_Level.Hall_Counter / Ca1_Lenght_Segment;

                  /* Current_Read = Current; */
                  Ca1_Current_Read = 0;
                  Ca1_Counter_Sample_Current = 1;
                  Ca1_Index_peak_time = 0;
                  Ca1_Counter_Time = 0;
               }
               else {
                  if ((APSA_INPUT_Mota.Check_Antipinch == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_BACKWARD) &&
                   (APSA_INPUT_Low_Level.Enable_APSA == APSA_ACTIVE)) {
                     /* State transition from APSA/APSA_chart.IDLE to APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD */
                     SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca16_ANTIPINCH__IVE_BACKWARD_id;

                     /* ex: EERAM_Current_Map_Backward_Write = EERAM_Current_Map_Backward_Write - (Average_Difference); */
                     Ca1_Counter_Time = 0;

                     /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_INRUSH_TIME_BACKWARD */
                     Ca1_Current_Peak = Ca23_average_filter;
                     SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD = 1;
                  }
               }
            }
         }

         /* End execution of state APSA/APSA_chart.IDLE */
         break;
      }
      case Ca14_WRITE_MAP_FORWARD_id: {
         /* Begin execution of state APSA/APSA_chart.WRITE_MAP_FORWARD */
         if (APSA_INPUT_Mota.Write_Map == APSA_NOT_ACTIVE) {
            /* State transition from APSA/APSA_chart.WRITE_MAP_FORWARD to APSA/APSA_chart.IDLE */
            SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca13_IDLE_id;

            /* # combined # BusOutport: APSA/APSA_OUTPUT */
            APSA_OUTPUT.Antipinch_Active = APSA_NOT_ACTIVE;
         }
         else {
            if ((APSA_INPUT_Mota.Write_Map == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_BACKWARD)) {
               /* State transition from APSA/APSA_chart.WRITE_MAP_FORWARD to APSA/APSA_chart.WRITE_MAP_BACKWARD */
               for (Aux_S32 = 0; Aux_S32 < 100; Aux_S32++)
               {
                  EERAM_Current_Map_Backward[Aux_S32] = 0;
               }
               SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca15_WRITE_MAP_BACKWARD_id;
               Ca1_Index_vector = Sa3_Sum / Ca1_Lenght_Segment;

               /* Current_Read = Current; */
               Ca1_Current_Read = 0;
               Ca1_Counter_Sample_Current = 1;
               Ca1_Counter_Time = 0;
               Ca1_Index_peak_time = 0;
            }
            else {
               if (Ca1_Counter_Time < PEAK_FILTER_TIME) {
                  Ca1_Counter_Time = Ca1_Counter_Time + 1;
                  if ((APSA_INPUT_Low_Level.Hall_Counter >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) && (Ca1_Index_vector <=
                   (MAX_NUM_ELEMENT - 1))) {
                     Ca1_Index_vector = Ca1_Index_vector + 1;
                  }
               }
               else {
                  /* [Counter_Time >= PEAK_FILTER_TIME]
                     Thi for cycle is used to erase the hit of the current */
                  while (Ca1_Index_peak_time <= Ca1_Index_vector) {
                     EERAM_Current_Map_Forward[Ca1_Index_peak_time] = Ca23_average_filter;
                     Ca1_Index_peak_time = Ca1_Index_peak_time + 1;
                  }
                  if (Ca1_Current_Read == 0) {
                     Ca1_Current_Read = Ca23_average_filter;
                  }
                  if ((APSA_INPUT_Low_Level.Hall_Counter >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) && (Ca1_Index_vector <=
                   (MAX_NUM_ELEMENT - 1))) {
                     if ((Ca1_Counter_Sample_Current == 0) || (Ca1_Current_Read == 0)) {
                        /* # combined # TargetLink outport: APSA/Current_Read_Average */
                        Current_Read_Average = Ca23_average_filter;
                     }
                     else {
                        /* # combined # TargetLink outport: APSA/Current_Read_Average */
                        Current_Read_Average = Ca1_Current_Read / Ca1_Counter_Sample_Current;
                     }

                     /* # combined # TargetLink outport: APSA/Current_Read_Average */
                     EERAM_Current_Map_Forward[Ca1_Index_vector] = Current_Read_Average;
                     Ca3_Check_Min_Threshold();
                     Ca1_Current_Read = Ca23_average_filter;
                     Ca1_Counter_Sample_Current = 1;
                     Ca1_Index_vector = Ca1_Index_vector + 1;
                  }
                  else {
                     Ca1_Current_Read = Ca1_Current_Read + Ca23_average_filter;
                     Ca1_Counter_Sample_Current = Ca1_Counter_Sample_Current + 1;
                  }
               }
            }
         }

         /* End execution of state APSA/APSA_chart.WRITE_MAP_FORWARD */
         break;
      }
      case Ca15_WRITE_MAP_BACKWARD_id: {
         /* Begin execution of state APSA/APSA_chart.WRITE_MAP_BACKWARD */
         if (APSA_INPUT_Mota.Write_Map == APSA_NOT_ACTIVE) {
            /* State transition from APSA/APSA_chart.WRITE_MAP_BACKWARD to APSA/APSA_chart.IDLE */
            SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca13_IDLE_id;

            /* # combined # BusOutport: APSA/APSA_OUTPUT */
            APSA_OUTPUT.Antipinch_Active = APSA_NOT_ACTIVE;
         }
         else {
            if ((APSA_INPUT_Mota.Write_Map == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_FORWARD)) {
               /* State transition from APSA/APSA_chart.WRITE_MAP_BACKWARD to APSA/APSA_chart.WRITE_MAP_FORWARD */
               for (Aux_S32 = 0; Aux_S32 < 100; Aux_S32++)
               {
                  EERAM_Current_Map_Forward[Aux_S32] = 0;
               }
               SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca14_WRITE_MAP_FORWARD_id;
               Ca1_Index_vector = APSA_INPUT_Low_Level.Hall_Counter / Ca1_Lenght_Segment;

               /* Current_Read = Current; */
               Ca1_Current_Read = 0;
               Ca1_Counter_Sample_Current = 1;
               Ca1_Index_peak_time = 0;
               Ca1_Counter_Time = 0;
            }
            else {
               if (Ca1_Counter_Time < PEAK_FILTER_TIME) {
                  Ca1_Counter_Time = Ca1_Counter_Time + 1;
                  if ((Sa3_Sum >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) && (Ca1_Index_vector <= (MAX_NUM_ELEMENT - 1))) {
                     Ca1_Index_vector = Ca1_Index_vector + 1;
                  }
               }
               else {
                  /* [Counter_Time >= PEAK_FILTER_TIME] */
                  while (Ca1_Index_peak_time <= Ca1_Index_vector) {
                     EERAM_Current_Map_Backward[Ca1_Index_peak_time] = Ca23_average_filter;
                     Ca1_Index_peak_time = Ca1_Index_peak_time + 1;
                  }
                  if (Ca1_Current_Read == 0) {
                     Ca1_Current_Read = Ca23_average_filter;
                  }
                  if ((Sa3_Sum >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) && (Ca1_Index_vector <= (MAX_NUM_ELEMENT - 1))) {
                     if ((Ca1_Counter_Sample_Current == 0) || (Ca1_Current_Read == 0)) {
                        /* # combined # TargetLink outport: APSA/Current_Read_Average */
                        Current_Read_Average = Ca23_average_filter;
                     }
                     else {
                        /* # combined # TargetLink outport: APSA/Current_Read_Average */
                        Current_Read_Average = Ca1_Current_Read / Ca1_Counter_Sample_Current;
                     }

                     /* # combined # TargetLink outport: APSA/Current_Read_Average */
                     EERAM_Current_Map_Backward[Ca1_Index_vector] = Current_Read_Average;
                     Ca3_Check_Min_Threshold();
                     Ca1_Current_Read = Ca23_average_filter;
                     Ca1_Counter_Sample_Current = 1;
                     Ca1_Index_vector = Ca1_Index_vector + 1;
                  }
                  else {
                     Ca1_Current_Read = Ca1_Current_Read + Ca23_average_filter;
                     Ca1_Counter_Sample_Current = Ca1_Counter_Sample_Current + 1;
                  }
               }
            }
         }

         /* End execution of state APSA/APSA_chart.WRITE_MAP_BACKWARD */
         break;
      }
      case Ca16_ANTIPINCH__IVE_BACKWARD_id: {
         /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD */
         if (APSA_INPUT_Mota.Check_Antipinch == APSA_NOT_ACTIVE) {
            /* State transition from APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD to APSA/APSA_chart.IDLE */
            if (SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD) {
               SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD = 0;
            }
            else {
               if (SIBFS_APSA_chart_a.Ca18_Antipinch_Active) {
                  SIBFS_APSA_chart_a.Ca18_Antipinch_Active = 0;
               }
               else {
                  if (SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD) {
                     SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD = 0;
                  }
               }
            }
            SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca13_IDLE_id;

            /* # combined # BusOutport: APSA/APSA_OUTPUT */
            APSA_OUTPUT.Antipinch_Active = APSA_NOT_ACTIVE;
         }
         else {
            if ((APSA_INPUT_Mota.Check_Antipinch == APSA_ACTIVE) && (APSA_INPUT_Mota.Cmd_Motor == APSA_CMD_FORWARD)) {
               /* State transition from APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD to APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD */
               if (SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD) {
                  SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD = 0;
               }
               else {
                  if (SIBFS_APSA_chart_a.Ca18_Antipinch_Active) {
                     SIBFS_APSA_chart_a.Ca18_Antipinch_Active = 0;
                  }
                  else {
                     if (SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD) {
                        SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD = 0;
                     }
                  }
               }
               SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca6_ANTIPINCH_ACTIVE_FORWARD_id;

               /* ex: EERAM_Current_Map_Forward_Write = EERAM_Current_Map_Forward_Write - (Average_Difference); */
               Ca1_Counter_Time = 0;

               /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.WAIT_INRUSH_TIME_FORWARD */
               Ca1_Current_Peak = Ca23_average_filter;
               SIBFS_APSA_chart_a.Ca7_WAIT_INRUSH_TIME_FORWARD = 1;
            }
            else {
               if (SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD) {
                  /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_INRUSH_TIME_BACKWARD */
                  if (Ca1_Counter_Time >= INRUSH_TIME) {
                     Ca1_Counter_Time = 0;

                     /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_ADAPTATION_TIME_BACKWARD */
                     SIBFS_APSA_chart_a.Ca17_WAIT_INRUSH_TIME_BACKWARD = 0;
                     SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD = 1;
                     Ca1_Average_Current = 0;
                     Ca1_Average_EERAM_Current_Map = 0;
                     Ca1_Average_Difference = 0;
                     Ca1_Segments_Cnt = 0;
                     Ca1_Index_vector = Sa3_Sum / Ca1_Lenght_Segment;
                  }
                  else {
                     if (Ca1_Counter_Time < INRUSH_TIME) {
                        Ca1_Counter_Time = Ca1_Counter_Time + 1;
                        if (Ca1_Counter_Time == (INRUSH_TIME - 1)) {
                           /* # combined # Unit delay: APSA/Unit Delay */
                           X_Sa1_Unit_Delay = 1;
                        }
                        else {
                           /* # combined # Unit delay: APSA/Unit Delay */
                           X_Sa1_Unit_Delay = 0;
                        }
                     }
                     if (Ca1_Current_Peak <= Ca23_average_filter) {
                        Ca1_Current_Peak = Ca23_average_filter;
                     }
                  }

                  /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_INRUSH_TIME_BACKWARD */
               }
               else {
                  if (!(SIBFS_APSA_chart_a.Ca18_Antipinch_Active)) {
                     if (SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD) {
                        /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_ADAPTATION_TIME_BACKWARD */
                        if (Ca1_Counter_Time >= ADAPTATION_TIME) {
                           /* State transition from APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_ADAPTATION_TIME_BACKWARD to APSA/APSA_chart.ANTIPIN
                              CH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD */
                           Ca1_Average_Current = Ca1_Average_Current / Ca1_Counter_Time;
                           Ca1_Average_EERAM_Current_Map = Ca1_Average_EERAM_Current_Map / Ca1_Segments_Cnt;
                           Ca1_Average_Difference = Ca1_Average_Current - Ca1_Average_EERAM_Current_Map;

                           /* EERAM_Current_Map_Backward_Write = EERAM_Current_Map_Backward_Write + Average_Difference; */
                           Ca1_Delta_Current_previuos = 0;

                           /* # combined # BusOutport: APSA/APSA_OUTPUT */
                           APSA_OUTPUT.Threshold_Attention_Update = (Int16) EERAM_Threshold_Att_Backward;
                           APSA_OUTPUT.Threshold_AntiPinch_Update = (Int16) EERAM_Threshold_Antipinch_Backward;
                           SIBFS_APSA_chart_a.Ca19_WAIT_ADAP__N_TIME_BACKWARD = 0;
                           Ca1_cnt_antipinch = 0;
                           Ca1_Index_vector = Sa3_Sum / Ca1_Lenght_Segment;
                           Ca1_Current_Read = Ca23_average_filter;
                           Ca1_Counter_Sample_Current = 1;
                           Ca1_Vbatt_Old = APSA_INPUT_Low_Level.Vbatt;
                           Ca1_APSA_Delay = 0;
                           Ca1_Cmd_Motor_Lift_Old = APSA_INPUT_Mota.Cmd_Motor_Lift;
                        }
                        else {
                           if (Ca1_Counter_Time < ADAPTATION_TIME) {
                              Ca1_Counter_Time = Ca1_Counter_Time + 1;
                              Ca1_Average_Current = Ca1_Average_Current + Ca23_average_filter;
                              if ((Sa3_Sum >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) && (Ca1_Index_vector <= (MAX_NUM_ELEMENT
                                - 1))) {
                                 Ca1_Average_EERAM_Current_Map = Ca1_Average_EERAM_Current_Map + EERAM_Current_Map_Backward[Ca1_Index_vector];
                                 Ca1_Index_vector = Ca1_Index_vector + 1;
                                 Ca1_Segments_Cnt = Ca1_Segments_Cnt + 1;
                              }
                           }
                        }

                        /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.WAIT_ADAPTATION_TIME_BACKWARD */
                     }
                     else {
                        /* Begin execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD */

                        /* # combined # BusOutport: APSA/APSA_OUTPUT */
                        if (APSA_OUTPUT.Antipinch_Active == APSA_ACTIVE) {
                           /* # combined # TargetLink outport: APSA/Current_Read_Average */
                           Current_Read_Average = 0;

                           /* State transition to APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.Antipinch_Active */
                           SIBFS_APSA_chart_a.Ca18_Antipinch_Active = 1;
                        }
                        else {
                           if (Ca1_APSA_Delay > 1) {
                              Ca1_APSA_Delay = Ca1_APSA_Delay - 1;
                           }
                           if (Ca1_cnt_antipinch <= T_ANTIPINCH) {
                              /* End of segment */
                              if ((Sa3_Sum >= ((Ca1_Index_vector * Ca1_Lenght_Segment) + Ca1_Lenght_Segment)) && (Ca1_Index_vector < (MAX_NUM_ELEMENT
                               - 1))) {
                                 /* this check is used to avoid currentread saturation 
                                    during drop delay */
                                 if (Ca1_APSA_Delay <= 1) {
                                    /* with voltage drop  || stop lift motor inhibit antipinch for DROP_DELAY */
                                    if (((Ca1_Vbatt_Old - APSA_INPUT_Low_Level.Vbatt) >= VBATT_DROP) || ((APSA_INPUT_Low_Level.Vbatt - Ca1_Vbatt_Old)
                                     >= VBATT_DROP) || ((APSA_INPUT_Mota.Cmd_Motor_Lift == APSA_CMD_STOP) && ((Ca1_Cmd_Motor_Lift_Old ==
                                     APSA_CMD_FORWARD) || (Ca1_Cmd_Motor_Lift_Old == APSA_CMD_BACKWARD)))) {
                                       Ca1_APSA_Delay = DROP_DELAY;
                                    }
                                    else {
                                       /* # combined # TargetLink outport: APSA/Current_Read_Average */
                                       Current_Read_Average = Ca1_Current_Read / Ca1_Counter_Sample_Current;

                                       /* # combined # TargetLink outport: APSA/Delta_Current_actual
                                          # combined # TargetLink outport: APSA/Current_Read_Average */
                                       Delta_Current_actual = Current_Read_Average - (EERAM_Current_Map_Backward[Ca1_Index_vector] +
                                        Ca1_Average_Difference) - Ca1_Delta_Current_previuos;
                                       if (Ca1_APSA_Delay == 1) {
                                          /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                          Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + Delta_Current_actual;
                                          Ca1_APSA_Delay = 0;
                                       }
                                       else {
                                          /* # combined # TargetLink outport: APSA/Delta_Current_actual
                                             # combined # BusOutport: APSA/APSA_OUTPUT */
                                          if ((Delta_Current_actual > APSA_OUTPUT.Threshold_AntiPinch_Update) && (Ca1_cnt_antipinch < T_ANTIPINCH)) {
                                             Ca1_cnt_antipinch = Ca1_cnt_antipinch + 1;
                                             if (L_SHIFT_ADAPTATION != 0) {
                                                /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + ((Delta_Current_actual <<
                                                 L_SHIFT_ADAPTATION) / DIV_ADAPTATION);
                                             }
                                             if (Ca1_cnt_antipinch >= T_ANTIPINCH) {
                                                /* # combined # BusOutport: APSA/APSA_OUTPUT */
                                                APSA_OUTPUT.Antipinch_Active = APSA_ACTIVE;
                                             }
                                          }
                                          else {
                                             Ca1_cnt_antipinch = 0;
                                             Ca1_UpdateTrh = APSA_FALSE;

                                             /* CHECK_ATTENTION_THRESHOLD
                                                UPPER_THRESHOLD
                                                # combined # TargetLink outport: APSA/Delta_Current_actual
                                                # combined # BusOutport: APSA/APSA_OUTPUT */
                                             if (Delta_Current_actual >= APSA_OUTPUT.Threshold_Attention_Update) {
                                                Ca22_CounterManagerUpBwd(APSA_FALSE);

                                                /* # combined # BusOutport: APSA/APSA_OUTPUT */
                                                Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + APSA_OUTPUT.Threshold_Attention_Update;
                                                if ((Ca1_UpdateTrh == APSA_TRUE) && (APSA_INPUT_Low_Level.Enable_Adaptation == APSA_TRUE)) {
                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   EERAM_Current_Map_Backward[Ca1_Index_vector] = EERAM_Current_Map_Backward[Ca1_Index_vector] +
                                                   (Delta_Current_actual / APSA_INPUT_DELTA.DELTA_1);
                                                }
                                             }
                                             else {
                                                /* Reset counter Up */
                                                Ca22_CounterManagerUpBwd(APSA_TRUE);

                                                /* LOWER_THRESHOLD
                                                   # combined # TargetLink outport: APSA/Delta_Current_actual
                                                   # combined # BusOutport: APSA/APSA_OUTPUT
                                                   # combined # TargetLink outport: APSA/Delta_Current_actual
                                                   # combined # BusOutport: APSA/APSA_OUTPUT
                                                   # combined # TargetLink outport: APSA/Current_Read_Average */
                                                if ((Delta_Current_actual <= (-APSA_OUTPUT.Threshold_Attention_Update)) && (Delta_Current_actual >
                                                 (-APSA_OUTPUT.Threshold_AntiPinch_Update)) && (Current_Read_Average > MIN_CURRENT_THRESHOLD)) {
                                                   Ca21_CounterManagerDownBwd(APSA_FALSE);

                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + Delta_Current_actual;
                                                   if ((Ca1_UpdateTrh == APSA_TRUE) && (APSA_INPUT_Low_Level.Enable_Adaptation == APSA_TRUE)) {
                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   EERAM_Current_Map_Backward[Ca1_Index_vector] = EERAM_Current_Map_Backward[Ca1_Index_vector] -
                                                   ((-Delta_Current_actual) / APSA_INPUT_DELTA.DELTA_2);
                                                   }
                                                }
                                                else {
                                                   /* Reset counter Down */
                                                   Ca21_CounterManagerDownBwd(APSA_TRUE);

                                                   /* # combined # TargetLink outport: APSA/Delta_Current_actual */
                                                   Ca1_Delta_Current_previuos = Ca1_Delta_Current_previuos + Delta_Current_actual;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                                 Ca3_Check_Min_Threshold();
                                 Ca1_Index_vector = Ca1_Index_vector + 1;
                                 Ca1_Current_Read = Ca23_average_filter;
                                 Ca1_Counter_Sample_Current = 1;
                                 Ca1_Vbatt_Old = APSA_INPUT_Low_Level.Vbatt;
                                 Ca1_Cmd_Motor_Lift_Old = APSA_INPUT_Mota.Cmd_Motor_Lift;
                              }
                              else {
                                 Ca1_Current_Read = Ca1_Current_Read + Ca23_average_filter;
                                 Ca1_Counter_Sample_Current = Ca1_Counter_Sample_Current + 1;
                              }
                           }
                        }

                        /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD */
                     }
                  }
               }
            }
         }

         /* End execution of state APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD */
         break;
      }
      default: {
         /* State transition to APSA/APSA_chart.IDLE */
         Ca1_Index_vector = 0;
         Ca1_Counter_Time = 0;
         Ca1_Segments_Cnt = 0;
         Ca1_Cnt_Fail_Sens_Current = 0;
         if ((APSA_INPUT_Mota.Lenght_Motor_Stroke % MAX_NUM_ELEMENT) == 0) {
            Ca1_Lenght_Segment = APSA_INPUT_Mota.Lenght_Motor_Stroke / MAX_NUM_ELEMENT;
         }
         else {
            Ca1_Lenght_Segment = (APSA_INPUT_Mota.Lenght_Motor_Stroke / MAX_NUM_ELEMENT) + 1;
         }
         SIBFS_APSA_chart_a.Ca1_APSA_chart_ns = (unsigned int) Ca13_IDLE_id;

         /* # combined # BusOutport: APSA/APSA_OUTPUT */
         APSA_OUTPUT.Antipinch_Active = APSA_NOT_ACTIVE;
         break;
      }
   }

   /* End execution of chart APSA/APSA_chart */

   /* BusOutport: APSA/APSA_OUTPUT */
   APSA_OUTPUT.Fail_Sens_Current = DD_Ca1_Fail_Sens_Current;
   APSA_OUTPUT.cnt_antipinch = (Int16) Ca1_cnt_antipinch;
   APSA_OUTPUT.Index_vector = Ca1_Index_vector;
}

/*------------------------------------------------------------------------------------------------------------------*\
  MODULE LOCAL FUNCTION DEFINITIONS
\*------------------------------------------------------------------------------------------------------------------*/

/****************************************************************************************************************************************************\
 ***  FUNCTION:
 ***      Ca11_CounterManagerDownFwd
 *** 
 ***  DESCRIPTION:
 ***      Graphical function: APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD.CounterManagerDownFwd
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***      UInt8              Ca11_ResetCounter   
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\****************************************************************************************************************************************************/
static void Ca11_CounterManagerDownFwd(UInt8 Ca11_ResetCounter)
{
   Ca1_BitMaskIndex = Ca1_Index_vector >> 3;
   Ca1_BitPosition = Ca1_Index_vector - (Ca1_BitMaskIndex << 3);
   Ca1_BitPosition = ((8 - Ca1_BitPosition) << 1) - 2;
   if (Ca11_ResetCounter == APSA_TRUE) {
      EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
      EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
   }
   else {
      /* if (Counter == 2) Counter = 3 clear both  the 2 bit  and update the threshold */
      if ((EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (COUNT_BIT_TWO << Ca1_BitPosition)) == (COUNT_BIT_TWO << Ca1_BitPosition)) {
         EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
         EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
         Ca1_UpdateTrh = APSA_TRUE;
      }
      else {
         /* if (Counter == 1) Counter = 2 */
         if ((EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (COUNT_BIT_ONE << Ca1_BitPosition)) == (COUNT_BIT_ONE << Ca1_BitPosition)) {
            EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
            EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] | (COUNT_BIT_TWO << Ca1_BitPosition);
         }
         else {
            EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownFwd[Ca1_BitMaskIndex] | (COUNT_BIT_ONE << Ca1_BitPosition);
         }
      }
   }
}

/****************************************************************************************************************************************************\
 ***  FUNCTION:
 ***      Ca12_CounterManagerUpFwd
 *** 
 ***  DESCRIPTION:
 ***      Graphical function: APSA/APSA_chart.ANTIPINCH_ACTIVE_FORWARD.CHECK_ANTIPINCH_FORWARD.CounterManagerUpFwd
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***      UInt8              Ca12_ResetCounter   
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\****************************************************************************************************************************************************/
static void Ca12_CounterManagerUpFwd(UInt8 Ca12_ResetCounter)
{
   Ca1_BitMaskIndex = Ca1_Index_vector >> 3;
   Ca1_BitPosition = Ca1_Index_vector - (Ca1_BitMaskIndex << 3);
   Ca1_BitPosition = ((8 - Ca1_BitPosition) << 1) - 2;
   if (Ca12_ResetCounter == APSA_TRUE) {
      EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
      EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
   }
   else {
      /* if (Counter == 2) Counter = 3 clear both  the 2 bit  and update the threshold */
      if ((EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (COUNT_BIT_TWO << Ca1_BitPosition)) == (COUNT_BIT_TWO << Ca1_BitPosition)) {
         EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
         EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
         Ca1_UpdateTrh = APSA_TRUE;
      }
      else {
         /* if (Counter == 1) Counter = 2  clear  the first bit and set the second bit */
         if ((EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (COUNT_BIT_ONE << Ca1_BitPosition)) == (COUNT_BIT_ONE << Ca1_BitPosition)) {
            EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] = (EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition))) |
             (COUNT_BIT_TWO << Ca1_BitPosition);
         }
         else {
            /* Set the first bit */
            EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpFwd[Ca1_BitMaskIndex] | (COUNT_BIT_ONE << Ca1_BitPosition);
         }
      }
   }
}

/****************************************************************************************************************************************************\
 ***  FUNCTION:
 ***      Ca21_CounterManagerDownBwd
 *** 
 ***  DESCRIPTION:
 ***      Graphical function: APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD.CounterManagerDownBwd
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***      UInt8              Ca21_ResetCounter   
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\****************************************************************************************************************************************************/
static void Ca21_CounterManagerDownBwd(UInt8 Ca21_ResetCounter)
{
   Ca1_BitMaskIndex = Ca1_Index_vector >> 3;
   Ca1_BitPosition = Ca1_Index_vector - (Ca1_BitMaskIndex << 3);
   Ca1_BitPosition = ((8 - Ca1_BitPosition) << 1) - 2;
   if (Ca21_ResetCounter == APSA_TRUE) {
      EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
      EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
   }
   else {
      /* if (Counter == 2) Counter = 3 */
      if ((EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (COUNT_BIT_TWO << Ca1_BitPosition)) == (COUNT_BIT_TWO << Ca1_BitPosition)) {
         EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
         EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
         Ca1_UpdateTrh = APSA_TRUE;
      }
      else {
         /* if (Counter == 1) Counter = 2 */
         if ((EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (COUNT_BIT_ONE << Ca1_BitPosition)) == (COUNT_BIT_ONE << Ca1_BitPosition)) {
            EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
            EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] | (COUNT_BIT_TWO << Ca1_BitPosition);
         }
         else {
            /* Counter = 1 */
            EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorDownBwd[Ca1_BitMaskIndex] | (COUNT_BIT_ONE << Ca1_BitPosition);
         }
      }
   }
}

/****************************************************************************************************************************************************\
 ***  FUNCTION:
 ***      Ca22_CounterManagerUpBwd
 *** 
 ***  DESCRIPTION:
 ***      Graphical function: APSA/APSA_chart.ANTIPINCH_ACTIVE_BACKWARD.CHECK_ANTIPINCH_BACKWARD.CounterManagerUpBwd
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***      UInt8              Ca22_ResetCounter   
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\****************************************************************************************************************************************************/
static void Ca22_CounterManagerUpBwd(UInt8 Ca22_ResetCounter)
{
   Ca1_BitMaskIndex = Ca1_Index_vector >> 3;
   Ca1_BitPosition = Ca1_Index_vector - (Ca1_BitMaskIndex << 3);
   Ca1_BitPosition = ((8 - Ca1_BitPosition) << 1) - 2;
   if (Ca22_ResetCounter == APSA_TRUE) {
      EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
      EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
   }
   else {
      /* if (Counter == 2) Counter = 3 */
      if ((EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (COUNT_BIT_TWO << Ca1_BitPosition)) == (COUNT_BIT_TWO << Ca1_BitPosition)) {
         EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
         EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_TWO << Ca1_BitPosition));
         Ca1_UpdateTrh = APSA_TRUE;
      }
      else {
         /* if (Counter == 1) Counter = 2 */
         if ((EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (COUNT_BIT_ONE << Ca1_BitPosition)) == (COUNT_BIT_ONE << Ca1_BitPosition)) {
            EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] & (~(COUNT_BIT_ONE << Ca1_BitPosition));
            EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] | (COUNT_BIT_TWO << Ca1_BitPosition);
         }
         else {
            /* Counter = 1 */
            EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] = EERAM_CounterVectorUpBwd[Ca1_BitMaskIndex] | (COUNT_BIT_ONE << Ca1_BitPosition);
         }
      }
   }
}

/****************************************************************************************************************************************************\
 ***  FUNCTION:
 ***      Ca3_Check_Min_Threshold
 *** 
 ***  DESCRIPTION:
 ***      Graphical function: APSA/APSA_chart.Check_Min_Threshold
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\****************************************************************************************************************************************************/
static void Ca3_Check_Min_Threshold(void)
{
   if (Ca23_average_filter <= MIN_CURRENT_THRESHOLD) {
      if (Ca1_Cnt_Fail_Sens_Current > MAX_CNT_MIN_CURRENT_THRESHOLD) {
         DD_Ca1_Fail_Sens_Current = APSA_TRUE;
      }
      else {
         Ca1_Cnt_Fail_Sens_Current = Ca1_Cnt_Fail_Sens_Current + 1;
      }
   }
   else {
      if (Ca1_Cnt_Fail_Sens_Current != 0) {
         Ca1_Cnt_Fail_Sens_Current = Ca1_Cnt_Fail_Sens_Current - 1;
      }
      else {
         DD_Ca1_Fail_Sens_Current = APSA_FALSE;
      }
   }
}


#endif /* APSA_C */
/*------------------------------------------------------------------------------------------------------------------*\
  END OF FILE
\*------------------------------------------------------------------------------------------------------------------*/
